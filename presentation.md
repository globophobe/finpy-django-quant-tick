---
theme: ./
---

# Django Quant Tick

å€‹äººãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ç´¹ä»‹

---

# These slides are at Connpass. So you can check them out.

ã‚¹ãƒ©ã‚¤ãƒ‰ã¯Connpassã«ã‚¢ãƒƒãƒ—ã•ã‚Œã¦ã„ã¾ã™ã€‚ æ˜¯éã¿ã¦ãã ã•ã„ã€‚

---

# Who am I?

ãŠå‰èª°?

---

# My name is Alex, and I'm from Canada ğŸ‡¨ğŸ‡¦

ã‚¢ãƒ¬ãƒƒã‚¯ã‚¹ã§ã™ã€‚ã‚«ãƒŠãƒ€ã‹ã‚‰æ¥ã¾ã—ãŸã€‚

---
layout: image-right
text: My username on Connpass is globophobe.
trans: Connpassã®ãƒ¦ãƒ¼ã‚¶åã¯globophobeã§ã™ã€‚
href: https://github.com/globophobe
caption: globophobe 
---

<img class="m-auto border-radius" style="max-width: 80%;" src="/assets/arex.jpg" />

---

# I am a full-remote engineer at <a href="https://creditengine.jp/"><img class="inline" style="height: 4rem;" src="/assets/credit-engine.svg" alt="Credit Engine" /></a>.

<a href="https://creditengine.jp/">ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚¨ãƒ³ã‚¸ãƒ³</a>ã®ãƒ•ãƒ«ãƒªãƒ¢ãƒ¼ãƒˆã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã§ã™ã€‚

---

# I write code with Django and Vue.js for a SaaS used by banks and other major companies.

Djangoã¨Vue.jsã§éŠ€è¡Œã‚„å¤§ä¼æ¥­ãŒåˆ©ç”¨ã—ã¦ã„ã‚‹SaaSã‚’é–‹ç™ºã—ã¦ã„ã¾ã™ã€‚

---

# If you are interested, our recruitment information is at <a href="https://www.wantedly.com/companies/creditengine">Wantedly</a>.

èˆˆå‘³ãŒã‚ã‚‹æ–¹ã€æ¡ç”¨æƒ…å ±ã¯<a href="https://www.wantedly.com/companies/creditengine">Wantedly</a>ã«ã‚ã‚Šã¾ã™ã€‚

---
layout: image-right
text: A few years ago, I became interested in this book.
trans: æ•°å¹´å‰ã€ã“ã®æœ¬ã«èˆˆå‘³ã«ãªã‚Šã¾ã—ãŸã€‚
href: https://www.amazon.co.jp/Advances-Financial-Machine-Learning-Marcos/dp/1119482089/
---

<img class="m-auto" style="max-width: 80%;" src="/assets/afml.jpg" />

---
layout: image-right
text: Currently, it is published in Japanese.
trans: ç¾åœ¨ã€æ—¥æœ¬èªã§å‡ºç‰ˆã•ã‚Œã¦ã„ã¾ã™ã€‚
href: https://www.amazon.co.jp/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%8A%E3%83%B3%E3%82%B9%E6%A9%9F%E6%A2%B0%E5%AD%A6%E7%BF%92-%E3%83%9E%E3%83%AB%E3%82%B3%E3%82%B9%E3%83%BB%E3%83%AD%E3%83%9A%E3%82%B9%E3%83%BB%E3%83%87%E3%83%BB%E3%83%97%E3%83%A9%E3%83%89/dp/4322134637/
---

<img class="m-auto" style="max-width: 60%;" src="/assets/afml-japanese.jpg" />

---

# I became obsessed with chapter 2.

ç¬¬ï¼’ç« ã«åŸ·ç€ãªã£ã¦ã—ã¾ã„ã¾ã—ãŸã€‚

---

# Chapter 2 is about Financial Data Structures.

ç¬¬2ç« ã¯è²¡å‹™ãƒ‡ãƒ¼ã‚¿ã«ã¤ã„ã¦ã§ã™ã€‚

---

# The most popular representation of financial price data is time based Japanese candlestick charts. 

é‡‘èä¾¡æ ¼ãƒ‡ãƒ¼ã‚¿ã¯ä¸€èˆ¬çš„ã«æ™‚é–“ãƒ™ãƒ¼ã‚¹ãƒ­ãƒ¼ã‚½ã‚¯è¶³ãƒãƒ£ãƒ¼ãƒˆã§è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

---
layout: image-right
text: Candlesticks contain open, high, low, and close data.
trans: ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã«ã¯ã€å§‹å€¤ã€é«˜å€¤ã€å®‰å€¤ã€çµ‚å€¤ã®ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã™ã€‚
---

<img class="m-auto" style="max-width: 90%;" src="/assets/candle.jpg" />

---
layout: image-right
text: There are up candles, and down candles.
trans: è‰²ã«ã‚ˆã£ã¦ã€ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã®å‹•å‘ãŒåˆ†ã‹ã‚Šã¾ã™ã€‚
---

<img class="m-auto" style="max-width: 90%;" src="/assets/candle-up-down.png" />

---

# However, there are problems with time based candlesticks.

ã—ã‹ã—ã€æ™‚é–“ãƒ™ãƒ¼ã‚¹ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã«ã¯å•é¡ŒãŒã‚ã‚Šã¾ã™ã€‚

---

# According to Lopez de Prado, time based sampling should be avoided because:
Pradoã•ã‚“ã«ã‚ˆã‚‹ã¨ã€æ™‚é–“ãƒ™ãƒ¼ã‚¹ã‚’é¿ã‘ã‚‹ç†ç”±ï¼š

---

# (1) First, markets do not process information at a constant time interval. 

å–å¼•ã®æ•°ã¯æ™‚é–“ã«ã‚ˆã£ã¦ã€æ™‚ã€…å¤šã„ã€æ™‚ã€…ã™ããªã„ã§ã™ã€‚

---

# For example, there are more trades at market open and close then at any other time during the day. 

ä¾‹ã€TradFiã®å–å¼•ã¯ä¸€æ—¥ã®æœ€åˆã¨æœ€å¾Œã®æ•°åˆ†ã«ã¯å¤šé‡è¡Œã‚ã‚Œã¾ã™ã€‚

---

# (2) Second, time-sampled series often exhibit poor statistical properties.

æ™‚é–“ãƒ™ãƒ¼ã‚¹ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã¯æ­£è¦åˆ†å¸ƒã«ã¯è¿‘ããªã„ãƒ‡ãƒ¼ã‚¿ãŒå¾—ã‚‰ã‚Œã¾ã™ã€‚

---

# For this reason, Lopez de Prado recommends tick, volume, or dollar-based bars.

ãªã‚“ã®ã§ã€ãƒ†ã‚£ãƒƒã‚¯ã€ãƒœãƒªãƒ¥ãƒ¼ãƒ ã€ã¾ãŸã¯ãƒ‰ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ãŒå‹§ã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

---

# A new candlestick is created after a threhold value is reached.

ã—ãã„å€¤ã«é”ã™ã‚‹ã¨ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã‚’ä½œæˆã•ã‚Œã¾ã™ã€‚

---
layout: code
text: For example, tick bars might create a new bar every 1000 transactions...
trans: ãŸã¨ãˆã°ã€ãƒ†ã‚£ãƒƒã‚¯ã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã ã¨ã€1000ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ¯ã«ã€
---

<table>
  <tr>
    <td>998</td>
    <td>999</td>
    <td>1000</td>
  </tr>
  <tr>
    <td>...</td>
    <td>...</td>
    <td>Tick bar</td>
  </tr>
</table>

---
layout: code
text: And, dollar bars might create a new bar every &dollar;1,000,000
trans: ãã—ã¦ã€ãƒ‰ãƒ«ã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã¯1,000,000ãƒ‰ãƒ«æ¯ã«ä½œæˆã•ã‚Œã¾ã™ã€‚
---

<table>
  <tr>
    <td>$999,998</td>
    <td>$999,999</td>
    <td>$1,000,000</td>
  </tr>
  <tr>
    <td>...</td>
    <td>...</td>
    <td>Dollar bar</td>
  </tr>
</table>

---

# When the markets are moving quickly, there will be more data points...

å–å¼•ãŒå¤šã„ã¨ãã«ã€ã‚ˆã‚Šå¤šãã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆãŒä½œæˆã•ã‚Œã€‚ã€‚ã€‚

---

# And, when markets are moving slowly, there will be fewer data points.

ãã—ã¦ã€å–å¼•ãŒã™ããªã„ã¨ãã«ã€ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆãŒå°‘ãªããªã‚Šã¾ã™ã€‚

---

# Tick, volume, or dollar bars could be useful for algorithmic trading.

ãƒ†ã‚£ãƒƒã‚¯ã€ãƒœãƒªãƒ¥ãƒ¼ãƒ ã€ã¾ãŸã¯ãƒ‰ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã¯botterã«è‰¯ã„ã‹ã‚‚çŸ¥ã‚Œã¾ã›ã‚“ã€‚

---
layout: code
text: But, there are challenges...
trans: èª²é¡ŒãŒã‚ã‚Šã¾ã™
---

1. Tick data is necessary to create such bars, and can be expensive.
   * å–å¼•ãƒ‡ãƒ¼ã‚¿ãŒå¿…è¦ã§ã™ã€‚ãŠé‡‘ã‚’ã‹ã‹ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
2. Creating the bars is computationally expensive.
   * ä½œæˆã«ã¯è¨ˆç®—ã‚³ã‚¹ãƒˆãŒã‹ã‹ã‚Šã¾ã™ã€‚ 

---
layout: code
text: Solutions
trans: è§£æ±º
---

1. Cryptocurrency exchanges often provide tick data for no charge, by API or S3 bucket.
   * ä»®æƒ³é€šè²¨å–å¼•æ‰€ã¯ã‚ˆãå–å¼•ãƒ‡ãƒ¼ã‚¿ã‚’ç„¡æ–™ã§APIã‹S3ã§æä¾›ã—ã¦ã„ã¾ã™ã€‚
2. Aggregating the data can reduce the computational cost.
   * ãƒ‡ãƒ¼ã‚¿ã‚’é›†ç´„ã—ã¦ã€è¨ˆç®—ã‚³ã‚¹ãƒˆã‚’å‰Šæ¸›ã™ã‚‹äº‹ãŒå‡ºæ¥ã¾ã™ã€‚

---

# To resolve those challenges, I developed <a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">Django Quant Tick</a>.

èª²é¡Œã‚’è§£æ±ºã™ã‚‹ãŸã‚ã«ã€<a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">Django Quant Tick</a>ã‚’é–‹ç™ºã—ã¾ã—ãŸã€‚

---

# <a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">django-quant-tick</a> downloads and aggregates high frequency trading data.

<a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">django-quant-tick</a>ã¯å–å¼•æ‰€ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰é›†ç´„ã—ã¦ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã‚’ä½œæˆã•ã‚Œã¾ã™ã€‚

---

# Raw ticks are aggregated if equal `symbol`, `timestamp`, `nanoseconds` and `tickRule`.

`symbol`ã€`timestmap`ã€`nanoseconds`ã€ãã—ã¦`tickRule`ã¯åŒã˜ã®å ´åˆã€è¤‡æ•°ã®å–å¼•ã¯é›†ç´„ã•ã‚Œã¾ã™ã€‚

---
layout: code
text: In the second sample, <code>"ticks"&#58; 4</code> indicates the data point was aggregated from 4 transactions.
trans: ï¼’ç•ªç›®ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã¯ï¼”ã¤ã®å–å¼•ã‹ã‚‰é›†ç´„ã•ã‚Œã¾ã—ãŸã€‚
---

```json
{ "timestamp": 1620000915.31424, "price": "57064.01", "volume": "566.6479018604", "notional": "0.00993004", "tickRule": -1, "ticks": 1 },
{ "timestamp": 1620000915.885381, "price": "57071.2", "volume": "9376.6869202914", "notional": "0.16429813", "tickRule": 1, "ticks": 4 }
```

---

# As described in the accompanying project <a style="text-decoration: none;" href="https://github.com/globophobe/cryptofeed-werks">cryptofeed-werks</a>, aggregating trades in this way can increase information, as they are either orders of size or stop loss cascades.

ä»˜éšã™ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ<a style="text-decoration: none;" href="https://github.com/globophobe/cryptofeed-werks">cryptofeed-werks</a>ã§èª¬æ˜é€šã‚Šã€ã“ã®ã‚ˆã†ã«ãƒ‡ãƒ¼ã‚¿ã‚’é›†ç´„ã•ã‚Œã‚‹ã¨ã€ãƒ‡ãƒ¼ã‚¿ã«æˆè¡Œæ³¨æ–‡ã¨ã‚¹ãƒˆãƒƒãƒ—ãƒ­ã‚¹ã‚«ã‚¹ã‚±ãƒ¼ãƒ‰ã®å½±éŸ¿ãŒåæ˜ ã•ã‚Œã¾ã™ã€‚

---

# As well, the number of data points can be reduced by 30-50%

ãã—ã¦ã€ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã®æ•°ã¯ï¼“ã€œï¼•å‰²ã¾ã§ã§å‰Šæ¸›ã™ã‚‹ã®ã‚’å¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

---

# By filtering those data points, for example by `min_volume >= 1000`, the number of can be reduced more.

ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‚’ã€ãŸã¨ãˆã° `min_volume >= 1000`ã§ã€ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã—ãŸã‚‰ã€ãã®æ•°ã¯ã‚ˆã‚Šæ¸›ã‚‰ã™ã“ã¨ãŒå‡ºæ¥ã¾ã™ã€‚

---
layout: code
text: The first data point from before is aggregated with the second.
trans: ä¸€ç•ªæœ€åˆã®ä¾‹ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã¯ï¼’ç•ªã‚ã¨çµåˆã•ã‚Œã¾ã™ã€‚
---

```json
"timestamp": 1620000915.885381,
"price": "57071.2",
"volume": "9376.6869202914",
"notional": "0.16429813",
"tickRule": 1,
"ticks": 4,
"high": '57071.2',
"low": '57064.01',
"totalBuyVolume": "9376.6869202914",
"totalVolume": "9943.3348221518",
"totalBuyNotional": "0.16429813",
"totalNotional": "0.17422817",
"totalBuyTicks": 4,
"totalTicks": 5
```

---

# So, 5 ticks have been aggregated into 1 data point.

ï¼•ã®å–å¼•ã¯ï¼‘ã®ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã«é›†ç´„ã•ã‚Œã¾ã—ãŸã€‚

---

# Regardless of `min_volume`, <br /><a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">django-quant-tick</a> also aggregates the final data point of each minute, so that 1 minute time based candlesticks can also be derived.

`min_volume`ã¯é–¢ä¿‚ãªãã€<br /><a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">django-quant-tick</a>ãŒå„åˆ†ã®æœ€çµ‚ãƒ‡ãƒ¼ã‚¿ãƒã‚¤ãƒ³ãƒˆã‚‚é›†ç´„ã™ã‚‹ãŸã‚ã€1åˆ†ã®æ™‚é–“ãƒ™ãƒ¼ã‚¹ã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã‚‚å°å‡ºã§ãã¾ã™ã€‚

---
layout: code
text: In such case, <code>volume</code>, <code>notional</code>, <code>tickRule</code>, and <code>ticks</code> are <code>None</code>.
trans: ãã®å ´åˆã€é–¢é€£ãŒã‚ã‚‹å€¤ã¯ <code>None</code> ã«ãªã‚Šã¾ã™ã€‚
---

```json
"timestamp": 1620000915.885381,
"price": "57071.2",
"volume": None,
"notional": None,
"tickRule": None,
"ticks": None,
"high": '57071.2',
"low": '57064.01',
"totalBuyVolume": "9376.6869202914",
"totalVolume": "9943.3348221518",
"totalBuyNotional": "0.16429813",
"totalNotional": "0.17422817",
"totalBuyTicks": 4,
"totalTicks": 5
```

---
layout: code
text: django-quant-tick assumes&#58;
trans: åŸºæœ¬ä»®å®šï¼š

---

1. Only aggregated data need be stored.
   * é›†ç´„ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ã¿ã‚’ä¿å­˜
2. Databases can become expensive. S3 and GCS are cheap.
   * ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã¯é«˜ã„ã§ã™ã€‚S3ã¨GCSã¯å®‰ã„ã§ã™ã€‚
3. The minimum possible data should be saved in the database, e.g. pagination keys.
   * å¯èƒ½ãªé™ã‚Šæœ€å°é™ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜ã™ã‚‹ã¹ãã§ã™ã€‚ãŸã¨ãˆã°ã€ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚­ãƒ¼ãªã©ã€‚

---

# One caveat, as described in the [notes](https://github.com/globophobe/django-quant-tick/blob/main/NOTES.md), data quality is a priority. More so than storage costs.

ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ã¤ã„ã¦ã€[æ›¸ã„ã¦ã‚ã‚Šã¾ã™](https://github.com/globophobe/django-quant-tick/blob/main/NOTES.md)ã‘ã©ã€ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚³ã‚¹ãƒˆã‚ˆã‚Šã‚‚ãƒ‡ãƒ¼ã‚¿å“è³ªãŒå„ªå…ˆã§ã™ã€‚

---

# The minimum time interval that <a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">django-quant-tick</a> collects data is 1 minute.

<a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">django-quant-tick</a>ã¯ãƒ‡ãƒ¼ã‚¿åé›†ã®æœ€ä½é™ã®æ™‚é–“é–“éš”ã¯1åˆ†ã§ã™ã€‚

---

# The reason is that aggregated data is validated using the volume of 1 minute time based candlesticks from the exchange API.

ç†ç”±ã¯é›†ç´„ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯å–å¼•æ‰€ã®APIã‹ã‚‰å–å¾—ã•ã‚Œã¦ã„ã‚‹ï¼‘åˆ†æ™‚é–“ãƒ™ãƒ¼ã‚¹ãƒ­ãƒ¼ã‚½ã‚¯ã®ãƒœãƒªãƒ¥ãƒ¼ãƒ ã§æ¤œè¨¼ã•ã‚Œã¦ã„ã¾ã™ã€‚

---

# Another caveat, S3 and GCS storage operations at 1 minute intervals can become expensive.

ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ã¤ã„ã¦ã€ã‚‚ã†ä¸€ç‚¹ã€ï¼‘åˆ†æ¯ã«ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã™ã‚‹ã¨ã€S3ã¨GCSã®ã‚³ã‚¹ãƒˆãŒé«˜ããªã‚Šã¾ã™ã€‚

---

# Whenever possible, <a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">django-quant-tick</a> partitions data at 1 hour intervals.

å‡ºæ¥ã‚‹ã ã‘ã€ <a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">django-quant-tick</a>ã¯1æ™‚é–“æ¯ã«ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã™ã€‚

---

# An hour of data can typically be downloaded, aggregated, validated, and saved within minutes or seconds.

ä¸€æ™‚é–“åˆ†ã¯é€šå¸¸ã«æ•°åˆ†ã¾ãŸã¯æ•°ç§’ä»¥å†…ã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€é›†ç´„ã€æ¤œè¨¼ã€ãã—ã¦ä¿å­˜ãŒå‡ºæ¥ã¾ã™ã€‚

---

# <a style="text-decoration: none;" href="https://github.com/globophobe/django-quant-tick">django-quant-tick</a> is intended for serverless deployment. The demo deploys to GCP Cloud Run, with GCP Cloud Scheduler for periodic execution.

ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ãƒ‡ãƒ—ãƒ­ã‚¤ã¯æƒ³å®šã§ã™ã€‚ãƒ‡ãƒ¢ã¯GCP Cloud Runã«ãƒ‡ãƒ—ãƒ­ã‚¤ã•ã‚Œã¦ã„ã¾ã™ã€‚å®šæœŸçš„ã«å®Ÿè¡Œã®ãŸã‚ã«ã€GCP Cloud Schedulerã‚’åˆ©ç”¨ã•ã‚Œã¾ã™ã€‚

---

# Basically, dollar bars are created by looping through the aggregated data with a `for loop`.

ç°¡å˜ã«è¨€ã†ã¨ã€ãƒ‰ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã¯`for loop`ã§è¡Œä¸€ã¤ä¸€ã¤ã®å€¤ã‚’æ•°ãˆã¦ä½œæˆã•ã‚Œã¦ã„ã¾ã™ã€‚

---

# They can be generated much faster by aggregating and filtering the data beforehand.

å‰ã‚‚ã£ã¦ãƒ‡ãƒ¼ã‚¿ã‚’é›†ç´„ã•ã‚Œã¦ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ã§ãƒ‡ãƒ¼ã‚¿ã®é‡ã‚’ç¸®å°ã™ã‚‹ã¨ã€ã‚ˆã‚Šæ—©ãä½œæˆã‚’ã™ã‚‹ã®ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚

---

# One might think that dollar bars created from raw ticks rather than aggregated data would be be more precise.

ãƒ‰ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã¯é›†ç´„ã•ã‚Œã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã§ä½œæˆã™ã‚‹ã‚ˆã‚Šã‚‚é›†ç´„ã•ã‚Œã¦ã„ãªã„ãƒ‡ãƒ¼ã‚¿ã§ä½œæˆã™ã‚‹ã®ã¯æ­£ç¢ºã ã¨æ€ã£ã¦ã—ã¾ã†ã‹ã‚‚çŸ¥ã‚Šã¾ã›ã‚“ã‘ã©ã€

---
layout: code
text: However, the final transaction frequently exceeds the threshold.
trans: ä¸€ç•ªæœ€å¾Œã®å–å¼•ã¯ã—ã°ã—ã°ã—ãã„å€¤ã‚’è¶…ãˆã¾ã™ã€‚
---

<table>
  <tr>
    <td>$999,998</td>
    <td>$999,999</td>
    <td>$1,099,999</td>
  </tr>
  <tr>
    <td>...</td>
    <td>...</td>
    <td>Dollar bar<br />
      <ul style="font-size: 0.75rem;">
        <li>Threshold is $1,000,000
          <ul style="list-style-type: circle;"><li>ã—ãã„å€¤ã¯$1,000,000ã§ã™</li></ul>
        </li>
        <li>Final transaction was $100,000
          <ul style="list-style-type: circle;"><li>æœ€å¾Œã®å–å¼•ã¯$100,000ã§ã—ãŸ</li></ul>
        </li>
      </ul>
    </td>
  </tr>
</table>

---

# For tick bars, raw ticks are absolutely better, and can be created by looping, for example in steps of 1000.

ãƒ†ã‚£ãƒƒã‚¯ã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã®å ´åˆã€é›†ç´„ã•ã‚Œã¦ã„ãªã„ãƒ‡ãƒ¼ã‚¿ã¯ä¸€ç•ªã„ã„ã§ã™ã€‚ãŸã¨ãˆã°1000ã‚¹ãƒ†ãƒƒãƒ—ã§ãƒ«ãƒ¼ãƒ—ã™ã‚‹äº‹ã§ç°¡å˜ã«ä½œæˆãŒå‡ºæ¥ã¾ã™ã€‚

---

# Before [MlFinlab](https://github.com/hudson-and-thames/mlfinlab) changed their license, in a PR I wondered about their use of a for loop.

[MlFinlab](https://github.com/hudson-and-thames/mlfinlab)ã¯ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã‚’å¤‰æ›´ã—ãŸå‰ã«ã€PRã‚’å‡ºã—ãŸæ™‚ã«ã€MlFinLabã®`for loop`ã§ãƒ‰ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒ­ãƒ¼ã‚½ã‚¯è¶³ã®ä½œæˆæ–¹æ³•ã¯ä¸€ç•ªæ—©ã„æ–¹æ³•ã‹ã©ã†ã‹ã¯ç–‘å•ã§ã—ãŸã€‚

---

# But after the fact, had to concede, there isn't much alternative.

ã—ã‹ã—ã€ãã‚Œä»¥é™ã€ã‚ˆã‚Šæ—©ãæ–¹æ³•æ€ã„ä»˜ã‘ã¾ã›ã‚“ã§ã—ãŸã€‚

---

# So, I created django-quant-tick.

ãªã‚“ã®ã§ã€django-quant-tick<br />ã®é–‹ç™ºã‚’å§‹ã¾ã‚Šã¾ã—ãŸã€‚

---

# As an aside, regarding cryptocurrency exchange APIs...

ä»®æƒ³é€šè²¨ã®å–å¼•æ‰€ã®APIã«ã¤ã„ã¦ã€‚ã€‚ã€‚

---
layout: image-right
text: Some of them are totally donkey balls (crazy).
trans: ã¡ã‚‡ã£ã¨ç‹‚ã£ã¦ã„ã‚‹APIä»•æ§˜ã‚‚å­˜åœ¨ã™ã‚‹ã¨æ€ã„ã¾ã™ã€‚
---

<img class="m-auto" src="/assets/donkey-balls.jpg" />

---

# For example, the FTX API for trades is paginated by timestamp, max 30 requests per second, 200 max results per request.

ãŸã¨ãˆã°ã€FTXã®å–å¼•ãƒ‡ãƒ¼ã‚¿APIã®ä»•æ§˜ã¯ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãƒšãƒ¼ã‚¸åŒ–ã€1ç§’ã‚ãŸã‚Šæœ€å¤§30ãƒªã‚¯ã‚¨ã‚¹ãƒˆã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã”ã¨ã«æœ€å¤§200ä»¶ã®çµæœã§ã™ã€‚

---

# The good: 30 requests per second.
è‰¯ã„äº‹ï¼š 1ç§’ã‚ãŸã‚Šæœ€å¤§30ãƒªã‚¯ã‚¨ã‚¹ãƒˆ

# The bad: 200 results per request.
æ‚ªã„äº‹ï¼š ãƒªã‚¯ã‚¨ã‚¹ãƒˆã”ã¨ã«æœ€å¤§200ä»¶

---

# Usually, the earliest timestamp in the result is the next pagination key.

å¤§ä½“ã€çµæœã®ä¸€ç•ªæœ€åˆã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã¯æ¬¡ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ã‚­ãƒ¼ã§ã™ã€‚

---

# Unfortunately, the FTX API occasionally returns more than 200 trades with the same timestamp.

æ®‹å¿µãªãŒã‚‰ã€FTXã®APIã¯æ™‚ã€…ã€åŒã˜ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒä»˜ã„ã¦ã„ã‚‹å–å¼•ã‚’200ä»¶ä»¥ä¸Šã‚’è¿”ã—ã¾ã™ã€‚

---

# In such case, the `pagination_id` needs to be adjusted a small amount until unique trades are captured again.

ãã®å ´åˆã€ãƒ¦ãƒ‹ãƒ¼ã‚¯ãƒ‡ãƒ¼ã‚¿ã‚’åé›†ãŒå‡ºæ¥ã‚‹ãŸã‚ã«ã€`pagination_id`ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã¡ã£ã“ã¨ãšã¤èª¿æ•´ã™ã‚‹ã®ãŒå¿…è¦ã§ã™ã€‚

---
layout: code
text: An extremely ugly but effective solution, adjusting microseconds&#58;
trans: ãã®è§£æ±ºã¨ã¯ï¼š
---

```python
if len(data) == MAX_RESULTS and not len(unique):
    pagination_id -= 1e-6
    return round(pagination_id, 6)
```

---

# ã¡ã‚‡ã£ã¨ã ã‘ã¿ã¦ã¿ã¾ã—ã‚‡ã†ï¼

---

# That's all thanks for listening!

ä»¥ä¸Šã§ã™ã€‚ã”æ¸…è´ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚

